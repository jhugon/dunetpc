////////////////////////////////////////////////////////////////////////
// Class:       RobustHitFinder
// Module Type: producer
// File:        RobustHitFinder_module.cc
//
// Generated at Thu Aug 18 04:21:10 2016 by Matthew Thiesse using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

/*************************************************

Use this package with care, as it is unvalidated (as of 25 Aug 2016).
Also note that it can take quite a while to run because
of the HitLineFitAlg. Also, I don't yet trust the random seeding
of the algorithm. Need to work on that...

Let me know if there are any issues/requests/comments. 

m.thiesse@sheffield.ac.uk

**************************************************/


#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindOneP.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/RandomNumberGenerator.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "larsim/RandomUtils/LArSeedService.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Wire.h"
#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RawData/ExternalTrigger.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardata/RecoBaseArt/HitCreator.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "larcore/Geometry/Geometry.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"

#include <math.h>
#include <memory>
#include <algorithm>
#include <fstream>
#include <iostream>
#include <vector>
#include <map>

#include "TMath.h"
#include "TVector3.h"
#include "TTree.h"
#include "TF1.h"

#include "CLHEP/Random/RandomEngine.h"

//for the counter position map
#include "dune/daqinput35t/PennToOffline.h"

#include "RobustHitFinderSupport.h"
#include "HitLineFitAlg.h"
#include "RMSHitFinderAlg.h"

namespace dune {
  class RobustHitFinder;
}

class dune::RobustHitFinder : public art::EDProducer {
public:
  explicit RobustHitFinder(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  RobustHitFinder(RobustHitFinder const &) = delete;
  RobustHitFinder(RobustHitFinder &&) = delete;
  RobustHitFinder & operator = (RobustHitFinder const &) = delete;
  RobustHitFinder & operator = (RobustHitFinder &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;

private:

  bool ValidTrigger(std::vector<unsigned int> evtTriggers, unsigned int & c1arg, unsigned int & c2arg, unsigned int & trignumarg);
  float TimeToDriftDist(float thistime, unsigned int thistpc);
  float TimeToDisplacement(float thistime);
  float TimeToX(float thistime, unsigned int thistpc);
  float hitGeomDist(TVector3 hitloc, TVector3 trigloc1, TVector3 trigloc2);

  TTree * fTree;
  int run;
  int event;
  unsigned int c1;
  unsigned int c2;
  unsigned int trignum;
  float c1x;
  float c1y;
  float c1z;
  float c2x;
  float c2y;
  float c2z;
  int channel;
  int tpc;
  int signalsize;
  std::vector<float> signal;
  std::vector<float> signalFilter;
  float baseline;
  float rms;
  float baselineFilter;
  float rmsFilter;
  float integral;
  float integralFilter;
  float sigmaintegral;
  float sigmaintegralFilter;
  float amplitude;
  float amplitudeFilter;
  float peaktick;
  float peaktickFilter;
  float peaktime;
  float peaktimeFilter;
  int begintick;
  int endtick;
  int width;
  float hitx;
  float hity;
  float hitz;
  float hiterrxlo;
  float hiterrxhi;
  float hiterrylo;
  float hiterryhi;
  float hiterrzlo;
  float hiterrzhi;
  float perpdist;
  float hitt;
  float driftdist;
  bool countercut;
  float fitconstant;
  float fitconstanterr;
  float fitlinear;
  float fitlinearerr;
  float fitquadratic;
  float fitquadraticerr;
  float fitchi2;
  float fitsumsqrresidual;
  float fitndf;
  float fitmle;
  bool fitsuccess;
  bool fitrealhit;
  float segmentlength;

  bool fMakeTree;
  bool fDoWireAssns;
  bool fDoRawDigitAssns;
  float fHitGeomDistanceCut;
  std::string fWireModuleLabel;
  std::string fDigitModuleLabel;
  std::string fCounterT0ModuleLabel;
  std::vector<float> fEfield;

  float fHorizRangeMin;
  float fHorizRangeMax;
  float fVertRangeMin;
  float fVertRangeMax;
  float fC1Vert;
  float fC1Horiz;
  float fC2Vert;
  float fC2Horiz;
  UInt_t fSeedValue;
  std::map<unsigned int, std::pair<TVector3, std::vector<TVector3> > > fCounterPositionMap;

  dune::HitLineFitAlg fFitAlg;
  dune::RMSHitFinderAlg fHitFinderAlg;

  art::ServiceHandle<geo::Geometry> fGeom;
  art::ServiceHandle<art::RandomNumberGenerator> fRng;
  art::ServiceHandle<sim::LArSeedService> fSeed;
  art::ServiceHandle<art::TFileService> fTfs;
  detinfo::DetectorClocks const * fClks;
  detinfo::DetectorProperties const * fDetProp;
};


dune::RobustHitFinder::RobustHitFinder(fhicl::ParameterSet const & p)
  :     fFitAlg(p.get<fhicl::ParameterSet>("HitLineFitAlg")),
	fHitFinderAlg(p.get<fhicl::ParameterSet>("RMSHitFinderAlg")),
	fClks(lar::providerFrom<detinfo::DetectorClocksService>()),
	fDetProp(lar::providerFrom<detinfo::DetectorPropertiesService>())

{
  this->reconfigure(p);

  fSeed->createEngine(*this,"HepJamesRandom","Seed");

  recob::HitCollectionCreator::declare_products(*this,
                                                /*instancename*/ "",
                                                fDoWireAssns,
                                                fDoRawDigitAssns);

}

void dune::RobustHitFinder::produce(art::Event & e)
{
  recob::HitCollectionCreator hcol(*this, e, fDoWireAssns, fDoRawDigitAssns);

  CLHEP::HepRandomEngine const & engine = fRng->getEngine("Seed");
  fFitAlg.SetSeed(engine.getSeed());

  // get wire signals, either recob::Wire or raw::RawDigit
  art::Handle< std::vector< raw::RawDigit> > digitHandle;
  art::Handle< std::vector< recob::Wire> > wireHandle;
  if (fDoWireAssns && !e.getByLabel(fWireModuleLabel,wireHandle))
    {
      mf::LogError("RobustHitFinder") << "No recob::Wires found when expected";
      hcol.put_into(e);
      return;
    }
  if (fDoRawDigitAssns && !e.getByLabel(fDigitModuleLabel,digitHandle))
    {
      mf::LogError("RobustHitFinder") << "No raw::RawDigits found when expected";
      hcol.put_into(e);
      return;
    }

  // Get all T0 products
  art::Handle< std::vector< anab::T0> > t0Handle;
  if (!e.getByLabel(fCounterT0ModuleLabel,t0Handle))
    {
      mf::LogError("RobustHitFinder") << "No T0s found in this event";
      hcol.put_into(e);
      return;
    }

  // get associated external triggers
  art::FindManyP<raw::ExternalTrigger> triggers(t0Handle,e,fCounterT0ModuleLabel);

  run = e.run();
  event = e.event();

  for (size_t i_t0 = 0; i_t0 < t0Handle->size(); i_t0++)
    {
      art::Ptr<anab::T0> pt0(t0Handle,i_t0);
      std::vector<art::Ptr<raw::ExternalTrigger> > trigvec = triggers.at(i_t0);

      std::vector<unsigned int> evtTriggers;
      for (auto const &trig : trigvec) evtTriggers.push_back(trig->GetTrigID());

      if (!ValidTrigger(evtTriggers,c1,c2,trignum)) continue;

      c1x = fCounterPositionMap[c1].first.X();
      c1y = fCounterPositionMap[c1].first.Y();
      c1z = fCounterPositionMap[c1].first.Z();
      c2x = fCounterPositionMap[c2].first.X();
      c2y = fCounterPositionMap[c2].first.Y();
      c2z = fCounterPositionMap[c2].first.Z();
      //std::cout << "c1 = (" << c1x << "," << c1y << "," << c1z << ")      c2 = (" << c2x << "," << c2y << "," << c2z << ")" << std::endl;

      float distancecut = fHitGeomDistanceCut;
      if (trignum == 111)
        {
          fHorizRangeMin = -10;
          fHorizRangeMax = 170;
          fVertRangeMin = -50;
          fVertRangeMax = 250;
          fC1Vert = c1x;
          fC1Horiz = c1z;
          fC2Vert = c2x;
          fC2Horiz = c2z;
          distancecut *= fabs(TMath::Sin(TMath::ATan2(c1z-c2z,c1x-c2x)));
        }
      if (trignum == 112 || trignum == 113)
        {
          fHorizRangeMin = -50;
          fHorizRangeMax = 250;
          fVertRangeMin = -10;
          fVertRangeMax = 170;
          fC1Vert = c1z;
          fC1Horiz = c1x;
          fC2Vert = c2z;
          fC2Horiz = c2x;
          distancecut *= fabs(TMath::Cos(TMath::ATan2(c1z-c2z,c1x-c2x)));
        }
      fFitAlg.SetCounterPositions(fC1Vert,fC1Horiz,fC2Vert,fC2Horiz);
      fFitAlg.SetRanges(fHorizRangeMin,fHorizRangeMax,fVertRangeMin,fVertRangeMax);

      std::map<int,dune::ChannelInformation> chanMap;
      std::vector<dune::HitInformation> hitVec;

      for (size_t i_wire = 0; i_wire < wireHandle->size(); i_wire++)
        {
          art::Ptr<recob::Wire> wire(wireHandle,i_wire);
          if (wire->View() != geo::kZ) continue;

          dune::ChannelInformation chan;

          chan.artWire = wire;

          chan.signalVec.clear();
          chan.signalFilterVec.clear();

          chan.channelID = wire->Channel();
          chan.tpcNum = fGeom->ChannelToWire(chan.channelID)[0].TPC;

          chan.signalSize = wire->NSignal();
          chan.signalVec = wire->Signal();

          fHitFinderAlg.FindHits(chan);

          if (chan.pulse_ends.size() < 1) continue;

          double wirexyz[3];
          fGeom->Wire(*(fGeom->ChannelToWire(chan.channelID).begin())).GetCenter(wirexyz);

          for (size_t i_hit = 0; i_hit < chan.pulse_ends.size(); i_hit++)
            {
              dune::HitInformation hit;
              hit.channelID = chan.channelID;
              int begin_index = chan.pulse_ends[i_hit].first;
              int end_index = chan.pulse_ends[i_hit].second;
              hit.hitBeginTick = begin_index;
              hit.hitEndTick = end_index;
              std::vector<float>::iterator beginitr = chan.signalVec.begin()+begin_index;
              std::vector<float>::iterator enditr = chan.signalVec.begin()+end_index;
              std::vector<float> pulse(beginitr,enditr);
              std::vector<float>::iterator fbeginitr = chan.signalFilterVec.begin()+begin_index;
              std::vector<float>::iterator fenditr = chan.signalFilterVec.begin()+end_index;
              std::vector<float> pulseFilter(fbeginitr,fenditr);
              hit.hitAmplitude = *std::max_element(beginitr,enditr)-chan.baseline;
              hit.hitAmplitudeFilter = *std::max_element(fbeginitr,fenditr)-chan.baselineFilter;
              hit.hitWidth = end_index-begin_index;
              hit.hitIntegral = std::accumulate(beginitr,enditr,0)-(hit.hitWidth*chan.baseline);
              hit.hitIntegralFilter = std::accumulate(fbeginitr,fenditr,0)-(hit.hitWidth*chan.baselineFilter);
              hit.hitSigmaIntegral = TMath::Sqrt(pulse.size())*TMath::RMS(pulse.size(),pulse.data());
              hit.hitSigmaIntegralFilter = TMath::Sqrt(pulseFilter.size())*TMath::RMS(pulseFilter.size(),pulseFilter.data());
              hit.hitPeakTick = std::distance(chan.signalVec.begin(),std::max_element(beginitr,enditr));
              hit.hitPeakTickFilter = std::distance(chan.signalFilterVec.begin(),std::max_element(fbeginitr,fenditr));
              hit.hitPeakTime = fClks->TPCTick2TrigTime(hit.hitPeakTick);
              hit.hitPeakTimeFilter = fClks->TPCTick2TrigTime(hit.hitPeakTickFilter);

              hit.hitt = hit.hitPeakTime - pt0->Time()/1000;
              hit.hitx = TimeToX(hit.hitt,chan.tpcNum);
              hit.hity = 2.;
              hit.hitz = static_cast<float>(wirexyz[2]);
              hit.hiterrxlo = TMath::Sqrt(fabs(hit.hitx-TimeToDisplacement(fClks->TPCTick2TrigTime(hit.hitBeginTick)-pt0->Time()/1000)));
              hit.hiterrxhi = TMath::Sqrt(fabs(hit.hitx-TimeToDisplacement(fClks->TPCTick2TrigTime(hit.hitEndTick)-pt0->Time()/1000)));
              hit.hiterrylo = 0.;
              hit.hiterryhi = 0.;
              hit.hiterrzlo = sqrt(0.5);
              hit.hiterrzhi = sqrt(0.5);
              hit.driftdist = TimeToDriftDist(hit.hitt,chan.tpcNum);
              hit.perpdist = hitGeomDist(TVector3(hit.hitx,2.,hit.hitz),TVector3(c1x,2.,c1z),TVector3(c2x,2.,c2z));
              hit.countercut = false;
              if (hit.perpdist < distancecut) hit.countercut = true;
              hit.fitrealhit = false;

              if (trignum == 111)
                {
                  hit.hithoriz = hit.hitz;
                  hit.hitvert = hit.hitx;
                  hit.hithorizerrlo = hit.hiterrzlo;
                  hit.hithorizerrhi = hit.hiterrzhi;
                  hit.hitverterrlo = hit.hiterrxlo;
                  hit.hitverterrhi = hit.hiterrxhi;
                }
              else if (trignum == 112 || trignum == 113)
                {
                  hit.hithoriz = hit.hitx;
                  hit.hitvert = hit.hitz;
                  hit.hithorizerrlo = hit.hiterrxlo;
                  hit.hithorizerrhi = hit.hiterrxhi;
                  hit.hitverterrlo = hit.hiterrzlo;
                  hit.hitverterrhi = hit.hiterrzhi;
                }

              recob::HitCreator temphit(*wire,
                                        fGeom->ChannelToWire(chan.channelID)[0],
                                        hit.hitBeginTick,
                                        hit.hitEndTick,
                                        hit.hitWidth,
                                        hit.hitPeakTick,
                                        sqrt(hit.hitWidth),
                                        hit.hitAmplitude,
                                        sqrt(hit.hitAmplitude),
                                        hit.hitIntegral,
                                        hit.hitSigmaIntegral,
                                        hit.hitIntegral,
                                        1,
                                        -1,
                                        1,
                                        int(hit.hitEndTick-hit.hitBeginTick+1));
              hit.artHit = temphit.move();

              hitVec.push_back(hit);
            }
          chanMap.emplace(std::make_pair(chan.channelID,chan));
        }

      dune::HitLineFitAlg::HitLineFitResults fitresult;
      int retval = fFitAlg.FindTrack(hitVec,fitresult);
      fitconstant = fitresult.fitconstant;
      fitconstanterr = fitresult.fitconstanterr;
      fitlinear = fitresult.fitlinear;
      fitlinearerr = fitresult.fitlinearerr;
      fitquadratic = fitresult.fitquadratic;
      fitquadraticerr = fitresult.fitquadraticerr;
      fitchi2 = fitresult.fitchi2;
      fitsumsqrresidual = fitresult.fitsumsqrresidual;
      fitmle = fitresult.fitmle;
      fitndf = fitresult.fitndf;
      fitsuccess = fitresult.fitsuccess;
      TF1 * model = new TF1("model","pol2",fHorizRangeMin,fHorizRangeMax);
      model->SetParameters(fitconstant,fitlinear,fitquadratic);
      if (retval == 1 || retval == 0)
        {
          for (size_t i_hit = 0; i_hit < hitVec.size(); ++i_hit)
            {
              dune::HitInformation & hit = hitVec.at(i_hit);
              dune::ChannelInformation & chan = chanMap[hit.channelID];
              channel = chan.channelID;
              tpc = chan.tpcNum;
              signalsize = chan.signalSize;
              signal = chan.signalVec;
              signalFilter = chan.signalFilterVec;
              baseline = chan.baseline;
              rms = chan.rms;
              baselineFilter = chan.baselineFilter;
              rmsFilter = chan.rmsFilter;
              integral = hit.hitIntegral;
              integralFilter = hit.hitIntegralFilter;
              sigmaintegral = hit.hitSigmaIntegral;
              sigmaintegralFilter = hit.hitSigmaIntegralFilter;
              amplitude = hit.hitAmplitude;
              amplitudeFilter = hit.hitAmplitudeFilter;
              peaktick = hit.hitPeakTick;
              peaktickFilter = hit.hitPeakTickFilter;
              peaktime = hit.hitPeakTime;
              peaktimeFilter = hit.hitPeakTimeFilter;
              begintick = hit.hitBeginTick;
              endtick = hit.hitEndTick;
              width = hit.hitWidth;
              hitx = hit.hitx;
              hity = hit.hity;
              hitz = hit.hitz;
              hiterrxlo = hit.hiterrxlo;
              hiterrxhi = hit.hiterrxhi;
              hiterrylo = hit.hiterrylo;
              hiterryhi = hit.hiterryhi;
              hiterrzlo = hit.hiterrzlo;
              hiterrzhi = hit.hiterrzhi;
              perpdist = hit.perpdist;
              hitt = hit.hitt;
              driftdist = hit.driftdist;
              countercut = hit.countercut;
              fitrealhit = hit.fitrealhit;

              segmentlength = 0.449;
              if (fitsuccess && fitrealhit)
                {
                  if (trignum == 111)
                    {
                      segmentlength *= sqrt(1+TMath::Power(TMath::Tan(TMath::ATan2(model->Eval(hitz+1)-model->Eval(hitz-1),2)),2)+(((c1y-c2y)*(c1y-c2y))/((c1z-c2z)*(c1z-c2z))));
                      //std::cout << "segmentlength=" << segmentlength << std::endl;
                      //std::cout << "model->Eval(hitz+1="  << hitz+1 << ")=" << model->Eval(hitz+1) << std::endl;
                      //std::cout << "model->Eval(hitz-1=" << hitz-1 << ")=" << model->Eval(hitz-1) << std::endl;
                      //std::cout << "ATan2()=" << TMath::ATan2(model->Eval(hitz+1)-model->Eval(hitz-1),2) << std::endl;
                      //std::cout << "Tan^2(ATan2)=" << TMath::Power(TMath::Tan(TMath::ATan2(model->Eval(hitz+1)-model->Eval(hitz-1),2)),2) << std::endl;
                      //std::cout << "(((c1y-c2y)*(c1y-c2y))/((c1z-c2z)*(c1z-c2z)))=" << (((c1y-c2y)*(c1y-c2y))/((c1z-c2z)*(c1z-c2z))) << std::endl;
                    }
                  else if (trignum == 112 || trignum == 113)
                    {
                      segmentlength *= sqrt(1+TMath::Power(TMath::Tan(TMath::ATan2(2,model->Eval(hitx+1)-model->Eval(hitx-1))),2)*(1+(((c1y-c2y)*(c1y-c2y))/((c1x-c2x)*(c1x-c2x)))));
                      //std::cout << "segmentlength=" << segmentlength << std::endl;
                      //std::cout << "model->Eval(hitx+1="  << hitx+1 << ")=" << model->Eval(hitx+1) << std::endl;
                      //std::cout << "model->Eval(hitx-1=" << hitx-1 << ")=" << model->Eval(hitx-1) << std::endl;
                      //std::cout << "ATan2()=" << TMath::ATan2(2,model->Eval(hitx+1)-model->Eval(hitx-1)) << std::endl;
                      //std::cout << "Tan^2(ATan2)=" << TMath::Power(TMath::Tan(TMath::ATan2(2,model->Eval(hitx+1)-model->Eval(hitx-1))),2) << std::endl;
                      //std::cout << "(((c1y-c2y)*(c1y-c2y))/((c1x-c2x)*(c1x-c2x)))=" << (((c1y-c2y)*(c1y-c2y))/((c1x-c2x)*(c1x-c2x))) << std::endl;
                    }
                }

              if (fMakeTree) fTree->Fill();
              if (fitrealhit)
                {
                  hcol.emplace_back(hit.artHit,chan.artWire);
                }
            }
        }
    }
  hcol.put_into(e);
}

void dune::RobustHitFinder::beginJob()
{
  DAQToOffline::MakeCounterPositionMap("","counterInformation.txt",fCounterPositionMap,0,0,0);

  if (fMakeTree)
    {
      fTree = fTfs->make<TTree>("RobustHitFinder","RobustHitFinder");
      fTree->Branch("run",&run,"run/I");
      fTree->Branch("event",&event,"event/I");
      fTree->Branch("c1",&c1,"c1/i");
      fTree->Branch("c2",&c2,"c2/i");
      fTree->Branch("trignum",&trignum,"trignum/i");
      fTree->Branch("c1x",&c1x,"c1x/F");
      fTree->Branch("c1y",&c1y,"c1y/F");
      fTree->Branch("c1z",&c1z,"c1z/F");
      fTree->Branch("c2x",&c2x,"c2x/F");
      fTree->Branch("c2y",&c2y,"c2y/F");
      fTree->Branch("c2z",&c2z,"c2z/F");
      fTree->Branch("channel",&channel,"channel/I");
      fTree->Branch("tpc",&tpc,"tpc/I");
      fTree->Branch("signalsize",&signalsize,"signalsize/I");
      //fTree->Branch("signal",&signal);
      //fTree->Branch("signalFilter",&signalFilter);
      fTree->Branch("baseline",&baseline,"baseline/F");
      fTree->Branch("rms",&rms,"rms/F");
      fTree->Branch("baselineFilter",&baselineFilter,"baselineFilter/F");
      fTree->Branch("rmsFilter",&rmsFilter,"rmsFilter/F");
      fTree->Branch("integral",&integral,"integral/F");
      fTree->Branch("integralFilter",&integralFilter,"integralFilter/F");
      fTree->Branch("sigmaintegral",&sigmaintegral,"sigmaintegral/F");
      fTree->Branch("sigmaintegralFilter",&sigmaintegralFilter,"sigmaintegralFilter/F");
      fTree->Branch("amplitude",&amplitude,"amplitude/F");
      fTree->Branch("amplitudeFilter",&amplitudeFilter,"amplitudeFilter/F");
      fTree->Branch("peaktick",&peaktick,"peaktick/F");
      fTree->Branch("peaktickFilter",&peaktickFilter,"peaktickFilter/F");
      fTree->Branch("peaktime",&peaktime,"peaktime/F");
      fTree->Branch("peaktimeFilter",&peaktimeFilter,"peaktimeFilter/F");
      fTree->Branch("begintick",&begintick,"begintick/I");
      fTree->Branch("endtick",&endtick,"endtick/I");
      fTree->Branch("width",&width,"width/I");
      fTree->Branch("hitx",&hitx,"hitx/F");
      fTree->Branch("hity",&hity,"hity/F");
      fTree->Branch("hitz",&hitz,"hitz/F");
      fTree->Branch("hiterrxlo",&hiterrxlo,"hiterrxlo/F");
      fTree->Branch("hiterrxhi",&hiterrxhi,"hiterrxhi/F");
      fTree->Branch("hiterrylo",&hiterrylo,"hiterrylo/F");
      fTree->Branch("hiterryhi",&hiterryhi,"hiterryhi/F");
      fTree->Branch("hiterrzlo",&hiterrzlo,"hiterrzlo/F");
      fTree->Branch("hiterrzhi",&hiterrzhi,"hiterrzhi/F");
      fTree->Branch("perpdist",&perpdist,"perpdist/F");
      fTree->Branch("hitt",&hitt,"hitt/F");
      fTree->Branch("driftdist",&driftdist,"driftdist/F");
      fTree->Branch("countercut",&countercut,"countercut/O");
      fTree->Branch("fitconstant",&fitconstant,"fitconstant/F");
      fTree->Branch("fitconstanterr",&fitconstanterr,"fitconstanterr/F");
      fTree->Branch("fitlinear",&fitlinear,"fitlinear/F");
      fTree->Branch("fitlinearerr",&fitlinearerr,"fitlinearerr/F");
      fTree->Branch("fitquadratic",&fitquadratic,"fitquadratic/F");
      fTree->Branch("fitquadraticerr",&fitquadraticerr,"fitquadraticerr/F");
      fTree->Branch("fitchi2",&fitchi2,"fitchi2/F");
      fTree->Branch("fitsumsqrresidual",&fitsumsqrresidual,"fitsumsqrresidual/F");
      fTree->Branch("fitndf",&fitndf,"fitndf/F");
      fTree->Branch("fitmle",&fitmle,"fitmle/F");
      fTree->Branch("fitsuccess",&fitsuccess,"fitsuccess/O");
      fTree->Branch("fitrealhit",&fitrealhit,"fitrealhit/O");
      fTree->Branch("segmentlength",&segmentlength,"segmentlength/F");
    }
}

void dune::RobustHitFinder::reconfigure(fhicl::ParameterSet const & p)
{
  fMakeTree = p.get<bool>("MakeTree");
  fDoWireAssns = p.get<bool>("DoWireAssns");
  fDoRawDigitAssns = p.get<bool>("DoRawDigitAssns");
  fHitGeomDistanceCut = p.get<float>("HitGeomDistanceCut");
  fCounterT0ModuleLabel = p.get<std::string>("CounterT0ModuleLabel");
  fWireModuleLabel = p.get<std::string>("WireModuleLabel");
  fDigitModuleLabel = p.get<std::string>("DigitModuleLabel");
  fEfield = p.get<std::vector<float> >("Efield");
}

bool dune::RobustHitFinder::ValidTrigger(std::vector<unsigned int> evtTriggers, unsigned int & c1arg, unsigned int & c2arg, unsigned int & trignumarg)
{
  int contains_111 = 0, contains_112 = 0, contains_113 = 0;
  int contains_Ntrigs = 0, contains_NU = 0, contains_NL = 0, contains_SU = 0, contains_SL = 0;
  int contains_EL = 0, contains_WU = 0, contains_TEL = 0;
  for (size_t i_c = 0; i_c < evtTriggers.size(); i_c++)
    {
      unsigned int trigID = evtTriggers[i_c];
      if (trigID >= 0 && trigID <= 5) contains_SL++;
      if (trigID >= 6 && trigID <= 15) contains_EL++;
      if (trigID >= 16 && trigID <= 21) contains_NL++;
      if (trigID >= 22 && trigID <= 27) contains_NU++;
      if (trigID >= 28 && trigID <= 37) contains_WU++;
      if (trigID >= 38 && trigID <= 43) contains_SU++;
      if (trigID >= 44 && trigID <= 92) contains_TEL++;
      if (trigID == 111) contains_111++;
      if (trigID == 112) contains_112++;
      if (trigID == 113) contains_113++;
      contains_Ntrigs++;
    }
  if (contains_111 + contains_112 + contains_113 != 1) return false;        // too many/few coincidences!
  if (contains_TEL &&
      (contains_NU || contains_NL || contains_SU || contains_SL || contains_EL || contains_WU)) return false;        // track probably doesn't go through detector
  if (contains_Ntrigs != 3) return false;        // too much/little going on!
  if (contains_111 && (contains_NU || contains_NL || contains_SU || contains_SL)) return false;        // 111 should not have NU/NL/SU/SL
  if (contains_112 && (contains_EL || contains_WU || contains_SU || contains_NL)) return false;        // 112 should not have EL/WU/SU/NL
  if (contains_113 && (contains_EL || contains_WU || contains_NU || contains_SL)) return false;        // 113 should not have EL/WU/NU/SL
  if (contains_111 && (!contains_EL || !contains_WU)) return false;        // incomplete trigger
  if (contains_112 && (!contains_NU || !contains_SL)) return false;        // incomplete trigger
  if (contains_113 && (!contains_SU || !contains_NL)) return false;        // incomplete trigger

  std::vector<unsigned int> counterIDs;
  trignumarg = 0;
  for (size_t i_c = 0; i_c < evtTriggers.size(); i_c++)
    {
      unsigned int trigID = evtTriggers[i_c];
      if (trigID >= 44 && trigID <= 100) continue;
      if (trigID >= 111 && trigID <= 113)
        {
          trignumarg = trigID;
          continue;
        }
      counterIDs.push_back(trigID);
    }
  if (counterIDs.size() != 2) return false;
  if (trignumarg == 0) return false;

  c1arg = 999; c2arg = 999;
  if (trignumarg == 112 || trignumarg == 113)
    {
      if (fCounterPositionMap[counterIDs[0]].first.X() > fCounterPositionMap[counterIDs[1]].first.X())
        {
          c1arg = counterIDs[0];
          c2arg = counterIDs[1];
        }
      else
        {
          c1arg = counterIDs[1];
          c2arg = counterIDs[0];
        }
    }
  else if (trignumarg == 111)
    {
      if (fCounterPositionMap[counterIDs[0]].first.Z() > fCounterPositionMap[counterIDs[1]].first.Z())
        {
          c1arg = counterIDs[0];
          c2arg = counterIDs[1];
        }
      else
        {
          c1arg = counterIDs[1];
          c2arg = counterIDs[0];
        }
    }
  if (c1arg == c2arg) return false;
  if (c1arg == 999 || c2arg == 999) return false;

  return true;
}


float dune::RobustHitFinder::TimeToDriftDist(float thistime, unsigned int thistpc)
{
  float vd = fDetProp->DriftVelocity(fEfield[0]);
  float v1 = fDetProp->DriftVelocity(fEfield[1]);
  float v2 = fDetProp->DriftVelocity(fEfield[2]);
  float v3 = fDetProp->DriftVelocity(fEfield[3]);

  float ld = -1, l1 = -1, l2 = -1, l3 = -1;

  try
    {
      if (thistpc == 1 || thistpc == 3 || thistpc == 5 || thistpc == 7)
        {
          ld = fGeom->TPC(thistpc).MaxX()-0.511;
          l1 = 0.511-fGeom->TPC(thistpc).PlaneLocation(0)[0];
          l2 = fGeom->TPC(thistpc).PlaneLocation(0)[0]-fGeom->TPC(thistpc).PlaneLocation(1)[0];
          l3 = fGeom->TPC(thistpc).PlaneLocation(1)[0]-fGeom->TPC(thistpc).PlaneLocation(2)[0];
        }
      else if (thistpc == 0 || thistpc == 2 || thistpc == 4 || thistpc == 6)
        {
          ld = -8.490-fGeom->TPC(thistpc).MinX();
          l1 = fGeom->TPC(thistpc).PlaneLocation(0)[0]+8.490;
          l2 = fGeom->TPC(thistpc).PlaneLocation(1)[0]-fGeom->TPC(thistpc).PlaneLocation(0)[0];
          l3 = fGeom->TPC(thistpc).PlaneLocation(2)[0]-fGeom->TPC(thistpc).PlaneLocation(1)[0];
        }
    }
  catch (cet::exception &e)
    {
      std::cout << e << std::endl;
      return -99999;
    }

  if (ld < 0 || l1 < 0 || l2 < 0 || l3 < 0) return -99999;

  float t3max = l3/v3;
  float t2max = t3max+(l2/v2);
  float t1max = t2max+(l1/v1);
  float tdmax = t1max+(ld/vd);

  if      (0     <= thistime && thistime < t3max) return v3*thistime;
  else if (t3max <= thistime && thistime < t2max) return l3+v2*(thistime-t3max);
  else if (t2max <= thistime && thistime < t1max) return l3+l2+v1*(thistime-t2max);
  else if (t1max <= thistime && thistime < tdmax) return l3+l2+l1+vd*(thistime-t1max);

  return -99999;
}

float dune::RobustHitFinder::TimeToDisplacement(float thistime)
{
  return thistime*fDetProp->DriftVelocity(fEfield[0]);
}

float dune::RobustHitFinder::TimeToX(float thistime, unsigned int thistpc)
{
  float driftdistance = TimeToDriftDist(thistime,thistpc);
  if (driftdistance < -89999) return -99999;
  try
    {
      if (thistpc == 1 || thistpc == 3 || thistpc == 5 || thistpc == 7)
        {
          return (fGeom->TPC(thistpc).PlaneLocation(2)[0]+driftdistance);
        }
      else if (thistpc == 0 || thistpc == 2 || thistpc == 4 || thistpc == 6)
        {
          return (fGeom->TPC(thistpc).PlaneLocation(2)[0]-driftdistance);
        }
    }
  catch (cet::exception &e)
    {
      std::cout << e << std::endl;
    }
  return -99999;
}

float dune::RobustHitFinder::hitGeomDist(TVector3 hitloc, TVector3 trigloc1, TVector3 trigloc2)
{
  return (((hitloc-trigloc1).Cross(hitloc-trigloc2)).Mag()/(trigloc2-trigloc1).Mag());
}

DEFINE_ART_MODULE(dune::RobustHitFinder)
