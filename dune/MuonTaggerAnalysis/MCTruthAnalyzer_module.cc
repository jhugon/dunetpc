////////////////////////////////////////////////////////////////////////
// Class:       MCTruthAnalyzer
// Module Type: analyzer
// File:        MCTruthAnalyzer_module.cc
//
// Generated at Tue Jun 28 16:02:09 2016 by JustinHugon using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"

#include <iostream>
#include <iomanip>
#include <string>

#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/TPCGeo.h"
#include "larcore/Geometry/AuxDetGeo.h"

#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/AuxDetSimChannel.h"

#include "TH1D.h"
#include "TH2D.h"
#include "TFile.h"
#include "TTree.h"
#include "TDatabasePDG.h"
#include "TMath.h"

class MCTruthAnalyzer;

class MCTruthAnalyzer : public art::EDAnalyzer {
public:
  explicit MCTruthAnalyzer(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MCTruthAnalyzer(MCTruthAnalyzer const &) = delete;
  MCTruthAnalyzer(MCTruthAnalyzer &&) = delete;
  MCTruthAnalyzer & operator = (MCTruthAnalyzer const &) = delete;
  MCTruthAnalyzer & operator = (MCTruthAnalyzer &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  virtual void beginJob() override;
  virtual void endJob() override;

private:

  // Declare member data here.
  art::InputTag _mcTruthTag;

  TTree * _outtree;

  float _xb;
  float _yb;
  float _zb;
  float _tb;

  float _pxb;
  float _pyb;
  float _pzb;
  float _pEb;

  float _pb;
  float _thetab;
  float _costhetab;
  float _phib;

  float _thetazenithb;
  float _costhetazenithb;
  float _phizenithb;
};


MCTruthAnalyzer::MCTruthAnalyzer(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  _mcTruthTag = p.get<art::InputTag>("mcTruthTag");
  std::cout << "_mcTruthTag: " << _mcTruthTag << std::endl;

}

void MCTruthAnalyzer::beginJob()
{
  art::ServiceHandle<art::TFileService> tfs;
  _outtree = tfs->make<TTree>("tree","tree");

  _outtree->Branch("xb",&_xb,"xb/F");
  _outtree->Branch("yb",&_yb,"yb/F");
  _outtree->Branch("zb",&_zb,"zb/F");
  _outtree->Branch("tb",&_tb,"tb/F");

  _outtree->Branch("pxb",&_pxb,"pxb/F");
  _outtree->Branch("pyb",&_pyb,"pyb/F");
  _outtree->Branch("pzb",&_pzb,"pzb/F");
  _outtree->Branch("pEb",&_pEb,"pEb/F");

  _outtree->Branch("pb",&_pb,"pb/F");
  _outtree->Branch("thetab",&_thetab,"thetab/F");
  _outtree->Branch("costhetab",&_costhetab,"costhetab/F");
  _outtree->Branch("phib",&_phib,"phib/F");

  _outtree->Branch("thetazenithb",&_thetazenithb,"thetazenithb/F");
  _outtree->Branch("costhetazenithb",&_costhetazenithb,"costhetazenithb/F");
  _outtree->Branch("phizenithb",&_phizenithb,"phizenithb/F");

  ////// Experiment w/ Geometry

  art::ServiceHandle<geo::Geometry> geom;
  std::cout << "Geometry: Detector Name:      '" << geom->DetectorName() << "'" << std::endl;
  std::cout << "Geometry: Number of Cryostats: " << geom->Ncryostats() << std::endl;
  std::cout << "Geometry: Number of TPCs:      " << geom->TotalNTPC() << std::endl;
  std::cout << "Geometry: Number of OpDets:    " << geom->NOpDets() << std::endl;
  std::cout << "Geometry: Number of AuxDets:   " << geom->NAuxDets() << std::endl;

  for(auto& cryostat: geom->IterateCryostats())
  {
    std::cout << "Cryostat mass: " << cryostat.Mass() << std::endl;
    std::cout << "Cryostat width:  " << 2*cryostat.HalfWidth() << std::endl;
    std::cout << "Cryostat height: " << 2*cryostat.HalfHeight() << std::endl;
    std::cout << "Cryostat length: " << cryostat.Length() << std::endl;
  }

  for(auto& tpc: geom->IterateTPCs())
  {
    std::cout << "TPC X in: " << tpc.MinX() << ", " << tpc.MaxX() << std::endl;
    std::cout << "TPC Y in: " << tpc.MinY() << ", " << tpc.MaxY() << std::endl;
    std::cout << "TPC Z in: " << tpc.MinZ() << ", " << tpc.MaxZ() << std::endl;
    std::cout << "  TPC width: " << tpc.HalfWidth()*2 << std::endl;
    std::cout << "  TPC height: " << tpc.HalfHeight()*2 << std::endl;
    std::cout << "  TPC length: " << tpc.Length() << std::endl;
    std::cout << "  TPC active width:  " << tpc.ActiveHalfWidth()*2 << std::endl;
    std::cout << "  TPC active height: " << tpc.ActiveHalfHeight()*2 << std::endl;
    std::cout << "  TPC active length: " << tpc.ActiveLength() << std::endl;
    std::cout << "  TPC active mass: " << tpc.ActiveMass() << std::endl;
  }

  std::vector<geo::AuxDetGeo *> const & auxDetGeos = geom->AuxDetGeoVec();
  for(auto& auxDetGeoPtr: auxDetGeos)
  {
    //std::cout << "AuxDet Named: '" << auxDetGeoPtr->Name() << "'" << std::endl;
    std::cout << "AuxDet Length: '" << auxDetGeoPtr->Length() << "'" << std::endl;
  }

}

void MCTruthAnalyzer::analyze(art::Event const & e)
{
  // Implementation of required member function here.

  //Get needed data products
  auto mcTruthHand = e.getValidHandle<std::vector<simb::MCTruth>>(_mcTruthTag);
  std::vector<art::Ptr<simb::MCTruth>> mcTruthVec;
  art::fill_ptr_vector(mcTruthVec, mcTruthHand);

  art::ServiceHandle<geo::Geometry> geom;

  for (const auto& mcTruth : mcTruthVec)
  {
    size_t nParticles = mcTruth->NParticles();
    for (size_t iPart = 0; iPart < nParticles; iPart++)
    {
      const simb::MCParticle & mcPart = mcTruth->GetParticle(iPart);
      //std::cout << "MC Particle: PDG ID: " << mcPart.PdgCode() << "Status: " << mcPart.StatusCode() << " momentum [GeV]: " << mcPart.Momentum().Mag();
      //std::cout << " Px,Py,Pz:    " <<mcPart.Momentum().X() <<", "<<mcPart.Momentum().Y()<<", "<<mcPart.Momentum().Z()<<", "<< std::endl;
      //std::cout << " Start X,Y,Z: " <<mcPart.Position().X() <<", "<<mcPart.Position().Y()<<", "<<mcPart.Position().Z()<<", "<< std::endl;
      //std::cout << " End X,Y,Z:   " <<mcPart.EndPosition().X() <<", "<<mcPart.EndPosition().Y()<<", "<<mcPart.EndPosition().Z()<<", "<< std::endl;
      if (abs(mcPart.PdgCode()) != 13)
          continue;

      //_hitsFrontDet = hitsDetectorPlane(*mcPart,false); // front
      //_hitsBackDet = hitsDetectorPlane(*mcPart,true); // back

      _xb = mcPart.Position().X();
      _yb = mcPart.Position().Y();
      _zb = mcPart.Position().Z();
      _tb = mcPart.Position().T();

      _pxb = mcPart.Momentum().X();
      _pyb = mcPart.Momentum().Y();
      _pzb = mcPart.Momentum().Z();
      _pEb = mcPart.Momentum().T();

      _pb = mcPart.Momentum().Vect().Mag();
      _thetab = mcPart.Momentum().Theta();
      _costhetab = mcPart.Momentum().CosTheta();
      _phib = mcPart.Momentum().Phi();

      _costhetazenithb = _pyb/_pb;
      _thetazenithb = TMath::ACos(_costhetazenithb);
      _phizenithb = TMath::ATan2(_pzb,-_pxb);

    } // for iPart
  } // for mcTruth

  _outtree->Fill();
  
}

void MCTruthAnalyzer::endJob()
{
}

DEFINE_ART_MODULE(MCTruthAnalyzer)
