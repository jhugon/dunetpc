////////////////////////////////////////////////////////////////////////
// Class:       MCTruthTranslator
// Module Type: producer
// File:        MCTruthTranslator_module.cc
//
// Generated at Thu Jul 14 17:57:43 2016 by Justin Hugon using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "SimulationBase/MCTruth.h"
#include "SimulationBase/MCParticle.h"

#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/TPCGeo.h"

#include <memory>
#include <iostream>

class MCTruthTranslator;

class MCTruthTranslator : public art::EDProducer {
public:
  explicit MCTruthTranslator(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MCTruthTranslator(MCTruthTranslator const &) = delete;
  MCTruthTranslator(MCTruthTranslator &&) = delete;
  MCTruthTranslator & operator = (MCTruthTranslator const &) = delete;
  MCTruthTranslator & operator = (MCTruthTranslator &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  // Declare member data here.
  art::InputTag _mcTruthTag;

};


MCTruthTranslator::MCTruthTranslator(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  _mcTruthTag = p.get<art::InputTag>("mcTruthTag");
  std::cout << "_mcTruthTag: " << _mcTruthTag << std::endl;

  // Call appropriate produces<>() functions here.
  produces< std::vector< simb::MCTruth> >();
}

void MCTruthTranslator::produce(art::Event & e)
{
  // Implementation of required member function here.
  
  //Make Empty Product
  std::unique_ptr<std::vector<simb::MCTruth>> newTruthVecPtr(new std::vector<simb::MCTruth>);

  //Get needed data products
  auto mcTruthHand = e.getValidHandle<std::vector<simb::MCTruth>>(_mcTruthTag);
  std::vector<art::Ptr<simb::MCTruth>> mcTruthVec;
  art::fill_ptr_vector(mcTruthVec, mcTruthHand);

  art::ServiceHandle<geo::Geometry> geom;

  for (const auto& mcTruth : mcTruthVec)
  {
    simb::MCTruth newMCTruth;
    newMCTruth.SetOrigin(mcTruth->Origin());
    size_t nParticles = mcTruth->NParticles();
    for (size_t iPart = 0; iPart < nParticles; iPart++)
    {
      const simb::MCParticle & mcPart = mcTruth->GetParticle(iPart);
      simb::MCParticle newMCPart(mcPart);
      newMCTruth.Add(newMCPart);
    } // for iPart
    if(mcTruth->NeutrinoSet())
    {
      const simb::MCNeutrino & nu = mcTruth->GetNeutrino();
      newMCTruth.SetNeutrino(
        nu.CCNC(),
        nu.Mode(),
        nu.InteractionType(),
        nu.Target(),
        nu.HitNuc(),
        nu.HitQuark(),
        nu.W(),
        nu.X(),
        nu.Y(),
        nu.QSqr()
      );
    }
    //newTruthVecPtr->push_back(std::move(newMCTruth));
    newTruthVecPtr->push_back(newMCTruth);
  } // for mcTruth

  e.put(std::move(newTruthVecPtr));
}

DEFINE_ART_MODULE(MCTruthTranslator)
