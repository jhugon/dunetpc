////////////////////////////////////////////////////////////////////////
// Class:       MCTruthTranslator
// Module Type: producer
// File:        MCTruthTranslator_module.cc
//
// Generated at Thu Jul 14 17:57:43 2016 by Justin Hugon using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/MCParticle.h"

#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/TPCGeo.h"

#include <memory>
#include <iostream>

class MCTruthTranslator;

class MCTruthTranslator : public art::EDProducer {
public:
  explicit MCTruthTranslator(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MCTruthTranslator(MCTruthTranslator const &) = delete;
  MCTruthTranslator(MCTruthTranslator &&) = delete;
  MCTruthTranslator & operator = (MCTruthTranslator const &) = delete;
  MCTruthTranslator & operator = (MCTruthTranslator &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  simb::MCParticle createTranslatedMCParticle(const simb::MCParticle& mcPart, float transX, float transY, float transZ, float transT) const;

  // Declare member data here.
  art::InputTag _mcTruthTag;
  float _translateX;
  float _translateY;
  float _translateZ;
  float _translateT;
};


MCTruthTranslator::MCTruthTranslator(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  _mcTruthTag = p.get<art::InputTag>("mcTruthTag");
  std::cout << "_mcTruthTag: " << _mcTruthTag << std::endl;

  _translateX = p.get<float>("translateX");
  std::cout << "_translateX: " << _translateX << std::endl;
  _translateY = p.get<float>("translateY");
  std::cout << "_translateY: " << _translateY << std::endl;
  _translateZ = p.get<float>("translateZ");
  std::cout << "_translateZ: " << _translateZ << std::endl;
  _translateT = p.get<float>("translateT");
  std::cout << "_translateT: " << _translateT << std::endl;

  // Call appropriate produces<>() functions here.
  produces< std::vector< simb::MCTruth> >();
}

void MCTruthTranslator::produce(art::Event & e)
{
  // Implementation of required member function here.
  
  //Make Empty Product
  std::unique_ptr<std::vector<simb::MCTruth>> newTruthVecPtr(new std::vector<simb::MCTruth>);

  //Get needed data products
  auto mcTruthHand = e.getValidHandle<std::vector<simb::MCTruth>>(_mcTruthTag);
  std::vector<art::Ptr<simb::MCTruth>> mcTruthVec;
  art::fill_ptr_vector(mcTruthVec, mcTruthHand);

  art::ServiceHandle<geo::Geometry> geom;

  for (const auto& mcTruth : mcTruthVec)
  {
    simb::MCTruth newMCTruth;
    newMCTruth.SetOrigin(mcTruth->Origin());
    size_t nParticles = mcTruth->NParticles();
    for (size_t iPart = 0; iPart < nParticles; iPart++)
    {
      const simb::MCParticle & mcPart = mcTruth->GetParticle(iPart);
      simb::MCParticle newMCPart = createTranslatedMCParticle(mcPart,_translateX,_translateY,_translateZ,_translateT);
      newMCTruth.Add(newMCPart);
    } // for iPart
    if(mcTruth->NeutrinoSet())
    {
      const simb::MCNeutrino & nu = mcTruth->GetNeutrino();
      newMCTruth.SetNeutrino(
        nu.CCNC(),
        nu.Mode(),
        nu.InteractionType(),
        nu.Target(),
        nu.HitNuc(),
        nu.HitQuark(),
        nu.W(),
        nu.X(),
        nu.Y(),
        nu.QSqr()
      );
    }
    //newTruthVecPtr->push_back(std::move(newMCTruth));
    newTruthVecPtr->push_back(newMCTruth);
  } // for mcTruth

  e.put(std::move(newTruthVecPtr));
}

simb::MCParticle MCTruthTranslator::createTranslatedMCParticle(const simb::MCParticle& mcPart, float transX, float transY, float transZ, float transT) const
{
  simb::MCParticle result(mcPart.TrackId(),mcPart.PdgCode(),mcPart.Process(),mcPart.Mother(),mcPart.Mass(),mcPart.StatusCode());
  result.SetPolarization(mcPart.Polarization());
  result.SetEndProcess(mcPart.EndProcess());
  for(int i=0; i < mcPart.NumberDaughters(); i++)
  {
    result.AddDaughter(mcPart.Daughter(i));
  }
  result.SetRescatter(mcPart.Rescatter());
  result.SetWeight(mcPart.Weight());
  result.SetGvtx(mcPart.Gvx(),mcPart.Gvy(),mcPart.Gvz(),mcPart.Gvt());
  for(unsigned i=0; i < mcPart.NumberTrajectoryPoints(); i++)
  {
    const TLorentzVector& pos = mcPart.Position(i);
    TLorentzVector newPos(pos.X()+_translateX,pos.Y()+_translateY,pos.Z()+_translateZ,pos.T()+_translateT);
    result.AddTrajectoryPoint(newPos,mcPart.Momentum(i));
  }

  return result;
}

DEFINE_ART_MODULE(MCTruthTranslator)
