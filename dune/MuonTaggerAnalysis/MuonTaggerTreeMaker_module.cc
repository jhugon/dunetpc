////////////////////////////////////////////////////////////////////////
// Class:       MuonTaggerTreeMaker
// Module Type: analyzer
// File:        MuonTaggerTreeMaker_module.cc
//
// Generated at Tue Jun 28 16:02:09 2016 by JustinHugon using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"

#include <iostream>
#include <iomanip>
#include <string>

#include "SimulationBase/MCTruth.h"
#include "SimulationBase/MCParticle.h"
#include "larcore/Geometry/Geometry.h"

#include "TH1D.h"
#include "TH2D.h"
#include "TFile.h"
#include "TTree.h"
#include "TDatabasePDG.h"

namespace dune {
  class MuonTaggerTreeMaker;
}

class dune::MuonTaggerTreeMaker : public art::EDAnalyzer {
public:
  explicit MuonTaggerTreeMaker(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MuonTaggerTreeMaker(MuonTaggerTreeMaker const &) = delete;
  MuonTaggerTreeMaker(MuonTaggerTreeMaker &&) = delete;
  MuonTaggerTreeMaker & operator = (MuonTaggerTreeMaker const &) = delete;
  MuonTaggerTreeMaker & operator = (MuonTaggerTreeMaker &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  virtual void beginJob() override;


private:

  // Declare member data here.
  art::InputTag _mcParticleTag;

  TTree* _outtree;

};


dune::MuonTaggerTreeMaker::MuonTaggerTreeMaker(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  _mcParticleTag = p.get<art::InputTag>("mcParticleTag");
  std::cout << "_mcParticleTag: " << _mcParticleTag << std::endl;
}

void dune::MuonTaggerTreeMaker::beginJob()
{
  art::ServiceHandle<art::TFileService> tfs;
  _outtree = tfs->make<TTree>("tree","tree");
}

void dune::MuonTaggerTreeMaker::analyze(art::Event const & e)
{
  // Implementation of required member function here.

  //Get needed data products
  auto mcPartHand = e.getValidHandle<std::vector<simb::MCParticle>>(_mcParticleTag);
  std::vector<art::Ptr<simb::MCParticle>> mcPartVec;
  art::fill_ptr_vector(mcPartVec, mcPartHand);

  for (const auto& mcPart : mcPartVec)
  {
    double partStartMom = mcPart->Momentum().Mag()*1000.; //in MeV/c
    //double partStartTheta = mcPart->Momentum().Vect().Theta()*180./M_PI; //in degrees
    //double partStartPhi = mcPart->Momentum().Vect().Phi()*180./M_PI; //in degrees
    std::cout << "MC Particle: PDG ID: " << mcPart->PdgCode() << "Status: " << mcPart->StatusCode() << " momentum [MeV]: " << partStartMom;
    //std::cout << " Theta [deg]: "<< partStartTheta << " Phi [deg]: "<< partStartPhi  << "  " << std::endl;
    std::cout << " Px,Py,Pz:    " <<mcPart->Momentum().X() <<", "<<mcPart->Momentum().Y()<<", "<<mcPart->Momentum().Z()<<", "<< std::endl;
    std::cout << " Start X,Y,Z: " <<mcPart->Position().X() <<", "<<mcPart->Position().Y()<<", "<<mcPart->Position().Z()<<", "<< std::endl;
    std::cout << " End X,Y,Z:   " <<mcPart->EndPosition().X() <<", "<<mcPart->EndPosition().Y()<<", "<<mcPart->EndPosition().Z()<<", "<< std::endl;
    //for(unsigned iPoint=0; iPoint<mcPart->NumberTrajectoryPoints(); iPoint++)
    //{
    //  std::cout << "   X,Y,Z:    " << std::setw(12) <<mcPart->Position(iPoint).X() <<", " << std::setw(12)<<mcPart->Position(iPoint).Y()<<", " << std::setw(12)<<mcPart->Position(iPoint).Z()<<", "<< std::endl;
    //}
  }
  
}


DEFINE_ART_MODULE(dune::MuonTaggerTreeMaker)
