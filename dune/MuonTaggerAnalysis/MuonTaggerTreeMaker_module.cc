////////////////////////////////////////////////////////////////////////
// Class:       MuonTaggerTreeMaker
// Module Type: analyzer
// File:        MuonTaggerTreeMaker_module.cc
//
// Generated at Tue Jun 28 16:02:09 2016 by JustinHugon using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"

#include <iostream>
#include <iomanip>
#include <string>

#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/TPCGeo.h"
#include "larcore/Geometry/AuxDetGeo.h"

#include "SimulationBase/MCTruth.h"
#include "SimulationBase/MCParticle.h"
#include "larsim/Simulation/SimChannel.h"
#include "larsim/Simulation/AuxDetSimChannel.h"

#include "TH1D.h"
#include "TH2D.h"
#include "TFile.h"
#include "TTree.h"
#include "TDatabasePDG.h"
#include "TMath.h"

class MinMaxFinder 
{
  private:
    float _min;
    float _max;
  public:
    MinMaxFinder();
    void addPoint(float x);
    float getMax() const {return _max;};
    float getMin() const {return _min;};
};

bool inATPC(const TLorentzVector& v, const geo::Geometry& geom, float minTPCWidth=20.)
{
  for(auto& tpc: geom.IterateTPCs())
  {
    if (tpc.HalfWidth()*2 > minTPCWidth)
    {
      if (tpc.ContainsPosition(v.Vect()))
      {
        return true;
      }
    }
  }
  return false;
}

MinMaxFinder::MinMaxFinder():
    _min(1e20), _max(-1e20)
{}

void MinMaxFinder::addPoint(float x)
{
  if (x > _max)
  {
    _max = x;
  }
  if (x < _min)
  {
    _min = x;
  }
}

namespace dune {
  class MuonTaggerTreeMaker;
}

class dune::MuonTaggerTreeMaker : public art::EDAnalyzer {
public:
  explicit MuonTaggerTreeMaker(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MuonTaggerTreeMaker(MuonTaggerTreeMaker const &) = delete;
  MuonTaggerTreeMaker(MuonTaggerTreeMaker &&) = delete;
  MuonTaggerTreeMaker & operator = (MuonTaggerTreeMaker const &) = delete;
  MuonTaggerTreeMaker & operator = (MuonTaggerTreeMaker &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  virtual void beginJob() override;
  virtual void endJob() override;

private:

  // Declare member data here.
  art::InputTag _mcParticleTag;
  art::InputTag _simChannelTag;
  art::InputTag _auxDetSimChannelTag;

  TTree* _outtree;
  TTree* _outtreeTrajPoints;
  TH1F* _trajectoryX;
  TH1F* _trajectoryY;
  TH1F* _trajectoryZ;

  // tree data members
  //

  float _xb;
  float _yb;
  float _zb;
  float _tb;
  float _xe;
  float _ye;
  float _ze;
  float _te;

  float _pxb;
  float _pyb;
  float _pzb;
  float _pEb;
  float _pxe;
  float _pye;
  float _pze;
  float _pEe;

  float _pb;
  float _thetab;
  float _costhetab;
  float _phib;

  float _thetazenithb;
  float _costhetazenithb;
  float _phizenithb;

  int _numberTrajectoryPoints;

  // treeTrajPoints data members
  float _tp_p;
  float _tp_E;
  float _tp_dEdx;
  bool _tp_inTPC;
  bool _tp_inWideTPC;

  MinMaxFinder _minMaxFinderTrajX;
  MinMaxFinder _minMaxFinderTrajY;
  MinMaxFinder _minMaxFinderTrajZ;
  MinMaxFinder _minMaxFinderTrajT;

  MinMaxFinder _minMaxFinderChanX;
  MinMaxFinder _minMaxFinderChanY;
  MinMaxFinder _minMaxFinderChanZ;
};


dune::MuonTaggerTreeMaker::MuonTaggerTreeMaker(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  _mcParticleTag = p.get<art::InputTag>("mcParticleTag");
  std::cout << "_mcParticleTag: " << _mcParticleTag << std::endl;
  _simChannelTag = p.get<art::InputTag>("simChannelTag");
  std::cout << "_simChannelTag: " << _simChannelTag << std::endl;
  _auxDetSimChannelTag = p.get<art::InputTag>("auxDetSimChannelTag");
  std::cout << "_auxDetSimChannelTag: " << _auxDetSimChannelTag << std::endl;
}

void dune::MuonTaggerTreeMaker::beginJob()
{
  art::ServiceHandle<art::TFileService> tfs;
  _outtree = tfs->make<TTree>("tree","tree");

  _outtree->Branch("xb",&_xb,"xb/F");
  _outtree->Branch("yb",&_yb,"yb/F");
  _outtree->Branch("zb",&_zb,"zb/F");
  _outtree->Branch("tb",&_tb,"tb/F");
  _outtree->Branch("xe",&_xe,"xe/F");
  _outtree->Branch("ye",&_ye,"ye/F");
  _outtree->Branch("ze",&_ze,"ze/F");
  _outtree->Branch("te",&_te,"te/F");

  _outtree->Branch("pxb",&_pxb,"pxb/F");
  _outtree->Branch("pyb",&_pyb,"pyb/F");
  _outtree->Branch("pzb",&_pzb,"pzb/F");
  _outtree->Branch("pEb",&_pEb,"pEb/F");
  _outtree->Branch("pxe",&_pxe,"pxe/F");
  _outtree->Branch("pye",&_pye,"pye/F");
  _outtree->Branch("pze",&_pze,"pze/F");
  _outtree->Branch("pEe",&_pEe,"pEe/F");

  _outtree->Branch("pb",&_pb,"pb/F");
  _outtree->Branch("thetab",&_thetab,"thetab/F");
  _outtree->Branch("costhetab",&_costhetab,"costhetab/F");
  _outtree->Branch("phib",&_phib,"phib/F");

  _outtree->Branch("thetazenithb",&_thetazenithb,"thetazenithb/F");
  _outtree->Branch("costhetazenithb",&_costhetazenithb,"costhetazenithb/F");
  _outtree->Branch("phizenithb",&_phizenithb,"phizenithb/F");

  _outtree->Branch("numberTrajectoryPoints",&_numberTrajectoryPoints,"numberTrajectoryPoints/I");

  //////////////// Trajectory Tree

  _outtreeTrajPoints = tfs->make<TTree>("treeTrajPoints","treeTrajPoints");
  _outtreeTrajPoints->Branch("pb",&_pb,"pb/F");
  _outtreeTrajPoints->Branch("thetazenithb",&_thetazenithb,"thetazenithb/F");
  _outtreeTrajPoints->Branch("p",&_tp_p,"p/F");
  _outtreeTrajPoints->Branch("E",&_tp_E,"E/F");
  _outtreeTrajPoints->Branch("dEdx",&_tp_dEdx,"dEdx/F");
  _outtreeTrajPoints->Branch("inTPC",&_tp_inTPC,"inTPC/O");
  _outtreeTrajPoints->Branch("inWideTPC",&_tp_inWideTPC,"inWideTPC/O");

  /////////////// Histos

  _trajectoryX = tfs->make<TH1F>("trajectoryX","",2000,-5000,5000);
  _trajectoryY = tfs->make<TH1F>("trajectoryY","",2000,-5000,1000);
  _trajectoryZ = tfs->make<TH1F>("trajectoryZ","",2000,-5000,5000);

  ////// Experiment w/ Geometry

  art::ServiceHandle<geo::Geometry> geom;
  std::cout << "Geometry: Detector Name:      '" << geom->DetectorName() << "'" << std::endl;
  std::cout << "Geometry: Number of Cryostats: " << geom->Ncryostats() << std::endl;
  std::cout << "Geometry: Number of TPCs:      " << geom->TotalNTPC() << std::endl;
  std::cout << "Geometry: Number of OpDets:    " << geom->NOpDets() << std::endl;
  std::cout << "Geometry: Number of AuxDets:   " << geom->NAuxDets() << std::endl;

  for(auto& cryostat: geom->IterateCryostats())
  {
    std::cout << "Cryostat mass: " << cryostat.Mass() << std::endl;
    std::cout << "Cryostat width:  " << 2*cryostat.HalfWidth() << std::endl;
    std::cout << "Cryostat height: " << 2*cryostat.HalfHeight() << std::endl;
    std::cout << "Cryostat length: " << cryostat.Length() << std::endl;
  }

  for(auto& tpc: geom->IterateTPCs())
  {
    std::cout << "TPC X in: " << tpc.MinX() << ", " << tpc.MaxX() << std::endl;
    std::cout << "TPC Y in: " << tpc.MinY() << ", " << tpc.MaxY() << std::endl;
    std::cout << "TPC Z in: " << tpc.MinZ() << ", " << tpc.MaxZ() << std::endl;
    std::cout << "  TPC width: " << tpc.HalfWidth()*2 << std::endl;
    std::cout << "  TPC height: " << tpc.HalfHeight()*2 << std::endl;
    std::cout << "  TPC length: " << tpc.Length() << std::endl;
    std::cout << "  TPC active width:  " << tpc.ActiveHalfWidth()*2 << std::endl;
    std::cout << "  TPC active height: " << tpc.ActiveHalfHeight()*2 << std::endl;
    std::cout << "  TPC active length: " << tpc.ActiveLength() << std::endl;
    std::cout << "  TPC active mass: " << tpc.ActiveMass() << std::endl;
  }

  std::vector<geo::AuxDetGeo *> const & auxDetGeos = geom->AuxDetGeoVec();
  for(auto& auxDetGeoPtr: auxDetGeos)
  {
    //std::cout << "AuxDet Named: '" << auxDetGeoPtr->Name() << "'" << std::endl;
    std::cout << "AuxDet Length: '" << auxDetGeoPtr->Length() << "'" << std::endl;
  }

}

void dune::MuonTaggerTreeMaker::analyze(art::Event const & e)
{
  // Implementation of required member function here.

  //Get needed data products
  auto mcPartHand = e.getValidHandle<std::vector<simb::MCParticle>>(_mcParticleTag);
  std::vector<art::Ptr<simb::MCParticle>> mcPartVec;
  art::fill_ptr_vector(mcPartVec, mcPartHand);

  auto simChanHand = e.getValidHandle<std::vector<sim::SimChannel>>(_simChannelTag);
  std::vector<art::Ptr<sim::SimChannel>> simChanVec;
  art::fill_ptr_vector(simChanVec, simChanHand);

  auto auxDetSimChanHand = e.getValidHandle<std::vector<sim::AuxDetSimChannel>>(_auxDetSimChannelTag);
  std::vector<art::Ptr<sim::AuxDetSimChannel>> auxDetSimChanVec;
  art::fill_ptr_vector(auxDetSimChanVec, auxDetSimChanHand);

  art::ServiceHandle<geo::Geometry> geom;

  for (const auto& mcPart : mcPartVec)
  {
    //std::cout << "MC Particle: PDG ID: " << mcPart->PdgCode() << "Status: " << mcPart->StatusCode() << " momentum [GeV]: " << mcPart->Momentum().Mag();
    //std::cout << " Px,Py,Pz:    " <<mcPart->Momentum().X() <<", "<<mcPart->Momentum().Y()<<", "<<mcPart->Momentum().Z()<<", "<< std::endl;
    //std::cout << " Start X,Y,Z: " <<mcPart->Position().X() <<", "<<mcPart->Position().Y()<<", "<<mcPart->Position().Z()<<", "<< std::endl;
    //std::cout << " End X,Y,Z:   " <<mcPart->EndPosition().X() <<", "<<mcPart->EndPosition().Y()<<", "<<mcPart->EndPosition().Z()<<", "<< std::endl;
    if (abs(mcPart->PdgCode()) != 13)
        continue;

    _xb = mcPart->Position().X();
    _yb = mcPart->Position().Y();
    _zb = mcPart->Position().Z();
    _tb = mcPart->Position().T();
    _xe = mcPart->EndPosition().X();
    _ye = mcPart->EndPosition().Y();
    _ze = mcPart->EndPosition().Z();
    _te = mcPart->EndPosition().T();

    _pxb = mcPart->Momentum().X();
    _pyb = mcPart->Momentum().Y();
    _pzb = mcPart->Momentum().Z();
    _pEb = mcPart->Momentum().T();
    _pxe = mcPart->EndMomentum().X();
    _pye = mcPart->EndMomentum().Y();
    _pze = mcPart->EndMomentum().Z();
    _pEe = mcPart->EndMomentum().T();

    _pb = mcPart->Momentum().Vect().Mag();
    _thetab = mcPart->Momentum().Theta();
    _costhetab = mcPart->Momentum().CosTheta();
    _phib = mcPart->Momentum().Phi();

    _costhetazenithb = _pyb/_pb;
    _thetazenithb = TMath::ACos(_costhetazenithb);
    _phizenithb = TMath::ATan2(_pzb,-_pxb);

    _numberTrajectoryPoints = mcPart->NumberTrajectoryPoints();

    for(unsigned iPoint=0; iPoint<mcPart->NumberTrajectoryPoints(); iPoint++)
    {
      bool isInATPC = inATPC(mcPart->Position(iPoint),*geom,0.);
      bool isInAWideTPC = inATPC(mcPart->Position(iPoint),*geom,20.);
      if (isInAWideTPC)
      {
        _trajectoryX->Fill(mcPart->Position(iPoint).X());
        _trajectoryY->Fill(mcPart->Position(iPoint).Y());
        _trajectoryZ->Fill(mcPart->Position(iPoint).Z());
        //std::cout << "   X,Y,Z:    " << std::setw(12) <<mcPart->Position(iPoint).X() <<", " << std::setw(12)<<mcPart->Position(iPoint).Y()<<", " << std::setw(12)<<mcPart->Position(iPoint).Z()<<", "<< std::endl;
        auto vec3 = mcPart->Position(iPoint).Vect();
        _minMaxFinderTrajX.addPoint(mcPart->Position(iPoint).X());
        _minMaxFinderTrajY.addPoint(mcPart->Position(iPoint).Y());
        _minMaxFinderTrajZ.addPoint(mcPart->Position(iPoint).Z());
        _minMaxFinderTrajT.addPoint(mcPart->Position(iPoint).T());
      }
      if (iPoint > 0)
      {
        //float pathLength = (vec3-mcPart->Position().Vect()).Mag();
        //float energyDiff = mcPart->Momentum(iPoint).E()-mcPart->Momentum().E();

        float dE = mcPart->Momentum(iPoint).E() - mcPart->Momentum(iPoint-1).E();
        float dx = (mcPart->Position(iPoint).Vect() - mcPart->Position(iPoint-1).Vect()).Mag();
        float mdEodx = - dE/dx;
        //std::cout << "     dE:    " << std::setw(12) <<dE <<" dx: " << std::setw(12)<<dx<<" -dE/dl " << std::setw(12)<<mdEodx<< std::endl;

        _tp_p = mcPart->Momentum(iPoint).Vect().Mag();
        _tp_E = mcPart->Momentum(iPoint).E();
        _tp_dEdx = mdEodx;
        _tp_inTPC = isInATPC;
        _tp_inWideTPC = isInAWideTPC;
        _outtreeTrajPoints->Fill();
      }
    }
  } // for mcPartVec

  for (const auto& simChan : simChanVec)
  {
    const std::map< unsigned short, std::vector< sim::IDE > > & tdcidemap = simChan->TDCIDEMap();
    for(auto& tdcidepair : tdcidemap)
    {
      //auto tdc = tdcidepair.first;
      auto ides = tdcidepair.second;
      //std::cout << "tdc: " << tdc << ", ide: " << std::endl;
      for (const auto& ide : ides)
      {
        //std::cout << "  x,y,z" << ide.x <<", " << ide.y << ", "<< ide.z << std::endl;
        _minMaxFinderChanX.addPoint(ide.x);
        _minMaxFinderChanY.addPoint(ide.x);
        _minMaxFinderChanZ.addPoint(ide.x);
      }
    }
    //simChan->Dump(std::cout);
    //std::cout << std::endl;
  } // for simChanVec

  //for (const auto& auxDetSimChan : auxDetSimChanVec)
  //{
  //  std::vector< sim::AuxDetIDE > const & auxDetIDEs = auxDetSimChan->AuxDetIDEs();
  //  for(const sim::AuxDetIDE& ide : auxDetIDEs)
  //  {
  //    std::cout << "auxDetIDE:\n";
  //    std::cout << "  entry x,y,z: " << ide.entryX << ", " << ide.entryZ << ", " << ide.entryZ << std::endl;
  //    std::cout << "  exit  x,y,z: " << ide.exitX << ", " << ide.exitZ << ", " << ide.exitZ << std::endl;
  //  }

  //} // for auxDetSimChanVec

  _outtree->Fill();
  
}

void dune::MuonTaggerTreeMaker::endJob()
{
  std::cout << "trajectory x in: "<< _minMaxFinderTrajX.getMin() << ", " << _minMaxFinderTrajX.getMax() << std::endl;
  std::cout << "trajectory y in: "<< _minMaxFinderTrajY.getMin() << ", " << _minMaxFinderTrajY.getMax() << std::endl;
  std::cout << "trajectory z in: "<< _minMaxFinderTrajZ.getMin() << ", " << _minMaxFinderTrajZ.getMax() << std::endl;
  std::cout << "trajectory t in: "<< _minMaxFinderTrajT.getMin() << ", " << _minMaxFinderTrajT.getMax() << std::endl;

  std::cout << std::endl;
  std::cout << "simchannelide x in: "<< _minMaxFinderChanX.getMin() << ", " << _minMaxFinderChanX.getMax() << std::endl;
  std::cout << "simchannelide y in: "<< _minMaxFinderChanY.getMin() << ", " << _minMaxFinderChanY.getMax() << std::endl;
  std::cout << "simchannelide z in: "<< _minMaxFinderChanZ.getMin() << ", " << _minMaxFinderChanZ.getMax() << std::endl;
}

DEFINE_ART_MODULE(dune::MuonTaggerTreeMaker)
