////////////////////////////////////////////////////////////////////////
// Class:       MuonTaggerTreeMaker
// Module Type: analyzer
// File:        MuonTaggerTreeMaker_module.cc
//
// Generated at Tue Jun 28 16:02:09 2016 by JustinHugon using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"

#include <iostream>
#include <iomanip>
#include <string>

#include "SimulationBase/MCTruth.h"
#include "SimulationBase/MCParticle.h"
#include "larcore/Geometry/Geometry.h"
#include "larsim/Simulation/SimChannel.h"

#include "TH1D.h"
#include "TH2D.h"
#include "TFile.h"
#include "TTree.h"
#include "TDatabasePDG.h"
#include "TMath.h"

class MinMaxFinder 
{
  private:
    float _min;
    float _max;
  public:
    MinMaxFinder();
    void addPoint(float x);
    float getMax() const {return _max;};
    float getMin() const {return _min;};
};

MinMaxFinder::MinMaxFinder():
    _min(1e20), _max(-1e20)
{}

void MinMaxFinder::addPoint(float x)
{
  if (x > _max)
  {
    _max = x;
  }
  if (x < _min)
  {
    _min = x;
  }
}


namespace dune {
  class MuonTaggerTreeMaker;
}

class dune::MuonTaggerTreeMaker : public art::EDAnalyzer {
public:
  explicit MuonTaggerTreeMaker(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MuonTaggerTreeMaker(MuonTaggerTreeMaker const &) = delete;
  MuonTaggerTreeMaker(MuonTaggerTreeMaker &&) = delete;
  MuonTaggerTreeMaker & operator = (MuonTaggerTreeMaker const &) = delete;
  MuonTaggerTreeMaker & operator = (MuonTaggerTreeMaker &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  virtual void beginJob() override;
  virtual void endJob() override;

private:

  // Declare member data here.
  art::InputTag _mcParticleTag;
  art::InputTag _simChannelTag;

  TTree* _outtree;
  TH1F* _trajectoryX;
  TH1F* _trajectoryY;
  TH1F* _trajectoryZ;

  // tree data members
  //

  float _xb;
  float _yb;
  float _zb;
  float _tb;
  float _xe;
  float _ye;
  float _ze;
  float _te;

  float _pxb;
  float _pyb;
  float _pzb;
  float _pEb;
  float _pxe;
  float _pye;
  float _pze;
  float _pEe;

  float _pb;
  float _thetab;
  float _costhetab;
  float _phib;

  float _thetazenithb;
  float _costhetazenithb;
  float _phizenithb;

  int _numberTrajectoryPoints;

  MinMaxFinder _minMaxFinderTrajX;
  MinMaxFinder _minMaxFinderTrajY;
  MinMaxFinder _minMaxFinderTrajZ;
  MinMaxFinder _minMaxFinderTrajT;

  MinMaxFinder _minMaxFinderChanX;
  MinMaxFinder _minMaxFinderChanY;
  MinMaxFinder _minMaxFinderChanZ;
};


dune::MuonTaggerTreeMaker::MuonTaggerTreeMaker(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  _mcParticleTag = p.get<art::InputTag>("mcParticleTag");
  std::cout << "_mcParticleTag: " << _mcParticleTag << std::endl;
  _simChannelTag = p.get<art::InputTag>("simChannelTag");
  std::cout << "_simChannelTag: " << _simChannelTag << std::endl;
}

void dune::MuonTaggerTreeMaker::beginJob()
{
  art::ServiceHandle<art::TFileService> tfs;
  _outtree = tfs->make<TTree>("tree","tree");

  _outtree->Branch("xb",&_xb,"xb/F");
  _outtree->Branch("yb",&_yb,"yb/F");
  _outtree->Branch("zb",&_zb,"zb/F");
  _outtree->Branch("tb",&_tb,"tb/F");
  _outtree->Branch("xe",&_xe,"xe/F");
  _outtree->Branch("ye",&_ye,"ye/F");
  _outtree->Branch("ze",&_ze,"ze/F");
  _outtree->Branch("te",&_te,"te/F");

  _outtree->Branch("pxb",&_pxb,"pxb/F");
  _outtree->Branch("pyb",&_pyb,"pyb/F");
  _outtree->Branch("pzb",&_pzb,"pzb/F");
  _outtree->Branch("pEb",&_pEb,"pEb/F");
  _outtree->Branch("pxe",&_pxe,"pxe/F");
  _outtree->Branch("pye",&_pye,"pye/F");
  _outtree->Branch("pze",&_pze,"pze/F");
  _outtree->Branch("pEe",&_pEe,"pEe/F");

  _outtree->Branch("pb",&_pb,"pb/F");
  _outtree->Branch("thetab",&_thetab,"thetab/F");
  _outtree->Branch("costhetab",&_costhetab,"costhetab/F");
  _outtree->Branch("phib",&_phib,"phib/F");

  _outtree->Branch("thetazenithb",&_thetazenithb,"thetazenithb/F");
  _outtree->Branch("costhetazenithb",&_costhetazenithb,"costhetazenithb/F");
  _outtree->Branch("phizenithb",&_phizenithb,"phizenithb/F");

  _outtree->Branch("numberTrajectoryPoints",&_numberTrajectoryPoints,"numberTrajectoryPoints/I");

  _trajectoryX = tfs->make<TH1F>("trajectoryX","",2000,-5000,5000);
  _trajectoryY = tfs->make<TH1F>("trajectoryY","",2000,-5000,1000);
  _trajectoryZ = tfs->make<TH1F>("trajectoryZ","",2000,-5000,5000);
}

void dune::MuonTaggerTreeMaker::analyze(art::Event const & e)
{
  // Implementation of required member function here.

  //Get needed data products
  auto mcPartHand = e.getValidHandle<std::vector<simb::MCParticle>>(_mcParticleTag);
  std::vector<art::Ptr<simb::MCParticle>> mcPartVec;
  art::fill_ptr_vector(mcPartVec, mcPartHand);

  auto simChanHand = e.getValidHandle<std::vector<sim::SimChannel>>(_simChannelTag);
  std::vector<art::Ptr<sim::SimChannel>> simChanVec;
  art::fill_ptr_vector(simChanVec, simChanHand);

  for (const auto& mcPart : mcPartVec)
  {
    //double partStartMom = mcPart->Momentum().Mag()*1000.; //in MeV/c
    //double partStartTheta = mcPart->Momentum().Vect().Theta()*180./M_PI; //in degrees
    //double partStartPhi = mcPart->Momentum().Vect().Phi()*180./M_PI; //in degrees
    //std::cout << "MC Particle: PDG ID: " << mcPart->PdgCode() << "Status: " << mcPart->StatusCode() << " momentum [MeV]: " << partStartMom;
    //std::cout << " Theta [deg]: "<< partStartTheta << " Phi [deg]: "<< partStartPhi  << "  " << std::endl;
    //std::cout << " Px,Py,Pz:    " <<mcPart->Momentum().X() <<", "<<mcPart->Momentum().Y()<<", "<<mcPart->Momentum().Z()<<", "<< std::endl;
    //std::cout << " Start X,Y,Z: " <<mcPart->Position().X() <<", "<<mcPart->Position().Y()<<", "<<mcPart->Position().Z()<<", "<< std::endl;
    //std::cout << " End X,Y,Z:   " <<mcPart->EndPosition().X() <<", "<<mcPart->EndPosition().Y()<<", "<<mcPart->EndPosition().Z()<<", "<< std::endl;
    if (abs(mcPart->PdgCode()) != 13)
        continue;

    _xb = mcPart->Position().X();
    _yb = mcPart->Position().Y();
    _zb = mcPart->Position().Z();
    _tb = mcPart->Position().T();
    _xe = mcPart->EndPosition().X();
    _ye = mcPart->EndPosition().Y();
    _ze = mcPart->EndPosition().Z();
    _te = mcPart->EndPosition().T();

    _pxb = mcPart->Momentum().X();
    _pyb = mcPart->Momentum().Y();
    _pzb = mcPart->Momentum().Z();
    _pEb = mcPart->Momentum().T();
    _pxe = mcPart->EndMomentum().X();
    _pye = mcPart->EndMomentum().Y();
    _pze = mcPart->EndMomentum().Z();
    _pEe = mcPart->EndMomentum().T();

    _pb = mcPart->Momentum().Vect().Mag();
    _thetab = mcPart->Momentum().Theta();
    _costhetab = mcPart->Momentum().CosTheta();
    _phib = mcPart->Momentum().Phi();

    _costhetazenithb = _pyb/_pb;
    _thetazenithb = TMath::ACos(_costhetazenithb);
    _phizenithb = TMath::ATan2(_pzb,-_pxb);

    _numberTrajectoryPoints = mcPart->NumberTrajectoryPoints();

    for(unsigned iPoint=0; iPoint<mcPart->NumberTrajectoryPoints(); iPoint++)
    {
      _trajectoryX->Fill(mcPart->Position(iPoint).X());
      _trajectoryY->Fill(mcPart->Position(iPoint).Y());
      _trajectoryZ->Fill(mcPart->Position(iPoint).Z());
      //std::cout << "   X,Y,Z:    " << std::setw(12) <<mcPart->Position(iPoint).X() <<", " << std::setw(12)<<mcPart->Position(iPoint).Y()<<", " << std::setw(12)<<mcPart->Position(iPoint).Z()<<", "<< std::endl;
      //auto vec3 = mcPart->Position(iPoint).Vect();
      //float pathLength = (vec3-mcPart->Position().Vect()).Mag();
      //float energyDiff = mcPart->Momentum(iPoint).E()-mcPart->Momentum().E();
      //float mdEodx = -energyDiff/pathLength;
      //std::cout << "   l:    " << std::setw(12) <<pathLength <<" energyDiff: " << std::setw(12)<<energyDiff<<" -dE/dl " << std::setw(12)<<mdEodx<< std::endl;
      _minMaxFinderTrajX.addPoint(mcPart->Position(iPoint).X());
      _minMaxFinderTrajY.addPoint(mcPart->Position(iPoint).Y());
      _minMaxFinderTrajZ.addPoint(mcPart->Position(iPoint).Z());
      _minMaxFinderTrajT.addPoint(mcPart->Position(iPoint).T());
    }
  }
  for (const auto& simChan : simChanVec)
  {
    const std::map< unsigned short, std::vector< sim::IDE > > & tdcidemap = simChan->TDCIDEMap();
    for(auto& tdcidepair : tdcidemap)
    {
      //auto tdc = tdcidepair.first;
      auto ides = tdcidepair.second;
      //std::cout << "tdc: " << tdc << ", ide: " << std::endl;
      for (const auto& ide : ides)
      {
        //std::cout << "  x,y,z" << ide.x <<", " << ide.y << ", "<< ide.z << std::endl;
        _minMaxFinderChanX.addPoint(ide.x);
        _minMaxFinderChanY.addPoint(ide.x);
        _minMaxFinderChanZ.addPoint(ide.x);
      }
    }
    //simChan->Dump(std::cout);
    //std::cout << std::endl;
  }

  _outtree->Fill();
  
}

void dune::MuonTaggerTreeMaker::endJob()
{
  std::cout << "trajectory x in: "<< _minMaxFinderTrajX.getMin() << ", " << _minMaxFinderTrajX.getMax() << std::endl;
  std::cout << "trajectory y in: "<< _minMaxFinderTrajY.getMin() << ", " << _minMaxFinderTrajY.getMax() << std::endl;
  std::cout << "trajectory z in: "<< _minMaxFinderTrajZ.getMin() << ", " << _minMaxFinderTrajZ.getMax() << std::endl;
  std::cout << "trajectory t in: "<< _minMaxFinderTrajT.getMin() << ", " << _minMaxFinderTrajT.getMax() << std::endl;

  std::cout << std::endl;
  std::cout << "simchannelide x in: "<< _minMaxFinderChanX.getMin() << ", " << _minMaxFinderChanX.getMax() << std::endl;
  std::cout << "simchannelide y in: "<< _minMaxFinderChanY.getMin() << ", " << _minMaxFinderChanY.getMax() << std::endl;
  std::cout << "simchannelide z in: "<< _minMaxFinderChanZ.getMin() << ", " << _minMaxFinderChanZ.getMax() << std::endl;
}

DEFINE_ART_MODULE(dune::MuonTaggerTreeMaker)
